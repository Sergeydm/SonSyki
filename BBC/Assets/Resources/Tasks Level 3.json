{
  "Items": [
    {
      "ID": 1,
      "Title": "Чёрные ящики",
      "Description": "  - Создай переменную boxesCount, хранящую кол-во открытых ящиков, со значением 0.\n  - Вызови цикл for со следующими параметрами:\n  for (var i = 0; i < 4; i++) {...}\n  - В фигурных скобках специальный метод робота для открытия ёмкостей OpenContainer()\n  - Ниже (в теле цикла) увеличь boxesCount на 1.\n  - После цикла верни boxesCount",
      "ExtendedDescription": "     Похоже, впереди завал. Надо бы его расчистить, да нечем - ни топора, ни пилы у нас нет. Попробуем поискать, только вот с чего начать?\n     На причалах лежат ящики, и, возможно, в них найдётся что-нибудь полезное. Что ж, пишем небольшую программку роботу - и вперёд. Но... похоже, программа не получится короткой: ящиков немало, и чтобы поработать с каждым из них, придётся написать одинаковые команды тоже для каждого. Как бы сделать так, чтобы написать <color=green><b>один код</b></color> и использовать его <color=green><b>несколько раз</b></color>?\n     Тут нам пригодятся очень важные для программирования конструкции - <color=green><b>циклы</b></color>. Они позволяют выполнить набор инструкций определённое количество раз и могут помочь существенно сократить код. Во всех языках они, по сути своей, работают одинаково, поэтому это фундаментальное знание будет особенно полезно.\n     Познакомимся с первым из них - циклом <color=green><b>for</b></color>. Он вызывается одноимённым оператором и использует в своей работе счётчик, помогающий определить, сколько раз необходимо выполнить набор команд и когда остановиться. Покажем на примере:\n     var number = 1;\n     for (var i = 0; i < 5; i++)\n     {\n         number *= 2;\n     }\n     Вызывая цикл for, мы задаём ему некоторые параметры, разделённые точкой с запятой. Первый из них - это переменная-счётчик, которая и будет изменяться. Зачастую это целое число, но это может быть и другой тип. Далее идёт условие, при котором цикл продолжает работать. Если оно становится ложным, выполнение цикла прекращается. Последний параметр - то, как изменяется счётчик после выполнения очередной <color=green><b>итерации</b></color> (шага) цикла. Далее в фигурных скобках идёт набор инструкций. Здесь все пишется так же, как и в условиях, в т.ч. можно так же не писать скобки, если в цикле будет выполняться одна строчка кода.\n     Используя эти знания, попробуем решить нашу задачу: нам нужно открыть каждый ящик, чтобы потом найти что-нибудь, что поможет разобрать завал. С этого момента мы начнём активнее использовать встроенный функционал робота, т.е. сами будем <color=green><b>вызывать</b></color> методы, который были предзаписаны в его память. Их не так много, но вместе с нашими программами они дадут отличный результат. Поехали!",
      "StartCode": "public int Execute()\n{\n    \n    \n}\n"
    },
    {
      "ID": 2,
      "Title": "Хорошая находка",
      "Description": "  - Объявите переменную itemsCount (кол-во предметов в ящиках) со значением 7\n  - Объявите цикл for со следующими параметрами:\n    - В качестве итератора объявите переменную i со значением 0;\n    - Условие работы цикла - i меньше itemsCount\n    - Как меняется итератор - увеличивается на 1\n  - В теле цикла напишите условие: если текущий предмет топор (вызовите метод IsAxe()) или пила (вызовите метод IsSaw(), нужно подобрать предмет (вызовите метод PickUp()) и завершить работу цикла (break))",
      "ExtendedDescription": "     Отлично, с for познакомились, ящики открыты! Теперь нужно проверить их содержимое. Закрепим знания о цикле for, применив его в этом задании, однако кое-что изменим.\n     Поскольку количество итераций может меняться, было бы неплохо хранить его в отдельной переменной, что мы сейчас и сделаем. Вдобавок вспомним про условия и используем их, ведь нам нужно найти именно топор или пилу. Если наше условие выполнится, будем подбирать предмет с помощью готового метода. Но если мы найдём два таких предмета, что делать? Второй нам точно не нужен, поэтому взять нужно только один. Значит, нужно как-то изменить поведение цикла, подстроить его под нашу ситуацию.\n     Тут на помощь придут специальные операторы, применяемые в циклах. Их два - <color=green><b>continue</b></color> и <color=green><b>break</b></color>. Оператор continue запускает новую итерацию цикла, не дожидаясь выполнения остальных инструкций, а break завершает работу цикла.\n     Сейчас нам интересен только break, он поможет завершить работу цикла, как только мы найдём подходящий инструмент. Будем его использовать внутри if-а, а в качестве условий будут выступать результаты работы пары методов.\n     Стоп, а разве можно  методы в условиях? Да, но только если они возвращают значение типа bool. Этим знанием мы будем пользоваться и в следующих заданиях.\n     Теперь приступим!",
      "StartCode": "public void Execute()\n{\n    \n    \n}\n"
    },
    {
      "ID": 3,
      "Title": "Путь свободен!",
      "Description": "  - Вызовите цикл while с условием !IsPathClear() (метод, проверяющий, свободен путь или нет, возвращает bool, из-за отрицания результат будет противоположный)\n  - В теле цикла вызовите метод UseAxe() (применение топора роботом)",
      "ExtendedDescription": "     Прекрасно! Мы нашли топор, а значит, мы можем попытаться убрать деревья с дороги. Если большие объекты робот не может передвинуть, то небольшие брёвна ему по силам. Осталось только написать программу.\n     Но вот вопрос: а сколько раз нужно выполнять команды в цикле? Деревьев много, довольно трудно посчитать их количество. Единственное, что мы знаем, так это когда нужно закончить - когда деревьев на дороге не останется. Есть ли способ выполнять программу, <color=green><b>пока</b></color> не выполнится некоторое условие?\n     Ответ - да. Нам пригодится другой очень важный цикл - <color=green><b>while</b></color>. Он не имеет счётчика и выполняет набор команд до тех пор, <color=green><b>пока</b></color> выполняется некоторое условие. Пример:\n     var number = 20.0;\n     while (number > 2)\n     {\n         number /= 2;\n     }\n     В данном примере переменная number будет уменьшаться в 2 раза, пока не станет меньше либо равной 2.\n     Удобство while заключается в том, что нам не нужно знать кол-во итераций, что полезно в некоторых ситуациях. В то же время нужно, чтобы условие остановки цикла могло однажды выполниться, иначе мы рискуем получить \"вечный\" цикл и нарушить работу программы.\n     Пришло время применить всё это на практике. Расчистим путь и продолжим наше путешествие! Как всегда, помимо циклов, нам помогут некоторые готовые методы.",
      "StartCode": "public void Execute()\n{\n    \n    \n}\n"
    },
    {
      "ID": 4,
      "Title": "Лесозаготовки",
      "Description": "  - Создай переменную treesCount (кол-во срубленных деревьев) со значением 0\n  - Объяви цикл: пока кол-во необходимых брёвен totalLogsCount больше 0, ...\n  - Внутри цикла вызывай метод использования топора UseAxe()\n  - Ниже увеличивай treesCount на 1\n  - Ниже напиши условие: если срубленное дерево высокое, уменьши totalLogsCount на 4, в противном случае уменьши на 2. Узнать, является ли дерево высоким, можно с помощью метода IsTreeTall() (возвращает true или false)\n  - После цикла верни treesCount",
      "ExtendedDescription": "     Мы всё ближе к деревне - уже различимы очертания домов и ограды. Пора перейти мост через реку. Вот только мост поднят, и хотя здесь есть рычаг, использовать его всё равно пока бесполезно: на мосту не хватает досок, а значит перейти никак не получится. Что ж, придётся нам самим его починить. Это нам по силам: в лесу мы уже восстанавливали переправу, так что есть опыт, к тому же, у нас есть топор, можно срубить деревья. Единственное, чего нам не хватает - программы.\n     Очевидно, что основой программы вновь станет цикл, но какой? Поскольку не ясно, сколько нам нужно срубить деревьев для моста, это будет while. Ещё надо учесть высоту деревьев, ведь с высоких можно получить больше брёвен. Условия, как и всегда, нас выручат.\n     Что ж, инструктаж окончен, приступаем к работе!",
      "StartCode": "public int Execute(int totalLogsCount)\n{\n    \n    \n}\n"
    },
    {
      "ID": 5,
      "Title": "Наводим мосты: Часть вторая",
      "Description": "  - Объяви цикл for, в котором итератор изменяется от 0 до partsCount с шагом 1\n  - В теле цикла вызови метод установки доски на мост SetUpBoard()\n  - Перед вызовом метода напиши условие: если номер текущей части моста (i) равен 2 или 7, переходим к следующей итерации (continue)",
      "ExtendedDescription": "     Самое тяжёлое позади, осталось прибить доски в нужных местах, и мост будет готов! Похоже, кто-то собирался чинить мост до нас, поэтому оставил здесь материалы и молоток. Он нам точно пригодится!\n     Что по программе? Всё просто: уже видно, сколько нам может понадобиться досок, поэтому условно разобьём мост на части и в for-е будем вызывать нужный метод. Но некоторые доски всё же сохранились, а значит там не надо их приколачивать. Как нам <color=green><b>пропустить</b></color> некоторые <color=green><b>итерации</b></color>?\n     В прошлых заданиях мы упоминали операторы циклов <color=green><b>continue</b></color> и <color=green><b>break</b></color>, но использовали только второй. Пришла очередь применить continue. Напомним, что он позволяет тут же завершить текущую итерацию цикла и перейти к следующей.\n     Вроде ничего сложного, поэтому приступим к починке моста!",
      "StartCode": "public void Execute(int partsCount)\n{\n    \n    \n}\n"
    },
    {
      "ID": 6,
      "Title": "",
      "Description": "",
      "ExtendedDescription": "",
      "StartCode": ""
    },
    {
      "ID": 7,
      "Title": "",
      "Description": "",
      "ExtendedDescription": "",
      "StartCode": ""
    },
    {
      "ID": 8,
      "Title": "",
      "Description": "",
      "ExtendedDescription": "",
      "StartCode": ""
    }
  ]
}